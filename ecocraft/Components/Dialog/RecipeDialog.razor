@using ecocraft.Models
@using ecocraft.Services
@inject ContextService ContextService
@inject UserServerDataService UserServerDataService
@inject PriceCalculatorService PriceCalculatorService

<MudDialog Style="min-height: 500px;">
    <DialogContent>
        <MudStack Spacing="2">
            <MudText>CraftingTable: @ContextService.GetTranslation(Recipe.CraftingTable)</MudText>
            @if (Recipe.Skill is not null)
            {
                <MudText>Skill: @ContextService.GetTranslation(Recipe.Skill) @(Recipe.SkillLevel)</MudText>
            }
            <MudStack Row>
                <MudText>Craft Time: @GetFormatedCraftTime(@Recipe.CraftMinutes)</MudText>
                <MudText Color="Color.Primary">@GetCraftMinutePrice() $</MudText>
            </MudStack>
            <MudStack Row>
                <MudText>Labor: @Recipe.Labor</MudText>
                <MudStack Row>
                    <MudText Color="Color.Primary">
                        @(Math.Round(GetLaborPrice(), 3)) $
                    </MudText>
                    <MudText>
                        (-@(Math.Round((1 - GetLaborReducePercent()), 1) * 100) %)
                    </MudText>
                </MudStack>
            </MudStack>

            <MudTable Items="GetUserElements()" GroupBy="_userElementsDefinition" Dense="true" Hover="true">
                <GroupHeaderTemplate>
                    <MudTh colspan="2" Class="mud-background">
                        <MudText>@context.Key</MudText>
                    </MudTh>
                    <MudTh colspan="1" Class="mud-background">
                        <MudText>$ / u</MudText>
                    </MudTh>
                    <MudTh colspan="3" Class="mud-background">
                        <MudStack Row Reverse="true">
                            @if (context.Key!.ToString() == "Ingredients")
                            {
                                <MudText Style="min-width: 60px" Typo="Typo.body2" Color="Color.Primary">
                                    @(Math.Round(-1 * (ElementSum(context.Items.ToList())) + GetLaborPrice(), 2)) $
                                    @(GetReintegratedElements().Count > 0 ? $"( {ElementSum(GetReintegratedElements(), false)} $)" : "")
                                </MudText>
                                <MudText Typo="Typo.body2">Total Cost:</MudText>
                            }
                            else
                            {
                                <MudText Style="min-width: 60px"  Typo="Typo.body2" Color="Color.Primary">
                                    @(Math.Round(ElementSum(GetProductsWithoutReintegratedElements(), false), 2)) $
                                </MudText>
                                <MudText Typo="Typo.body2">Total Price:</MudText>
                            }
                        </MudStack>
                    </MudTh>
                </GroupHeaderTemplate>
                <RowTemplate>
                    <MudTd Style="width: 30px">@(Math.Abs(context.Element.Quantity))</MudTd>
                    <MudTd>@ContextService.GetTranslation(context.Element.ItemOrTag)</MudTd>
                    <MudTd>
                        <MudText Typo="Typo.body2" Color="Color.Primary">
                            @if (context.Element.IsIngredient())
                            {
                                @(context.Price is not null ? Math.Round((float)context.Price!, 2) + " $" : "")
                            }
                            else
                            {
                                @(context.Price is not null ? Math.Round((float)context.Price!, 2) + " $" : "")                                
                            }                            
                        </MudText>
                    </MudTd>
                    <MudTd>@(context.Element.IsDynamic ? $"dynamic (-{Math.Round((1-GetModuleAndLavishReducePercent()),3) * 100} %)" : "static")</MudTd>
                    <MudTd>
                        @if (context.Element.Index > 0 && context.Element.IsProduct())
                        {
                        <MudSwitch T="bool"
                                   Color="Color.Primary"
                                   Value="context.IsReintegrated"
                                   ValueChanged="@(v => ChangeReintegrate(context, v))">
                            <MudText Typo="Typo.body2">Recovered Item</MudText>
                        </MudSwitch>
                        }
                    </MudTd>
                    <MudTd>
                        <MudText Typo="Typo.body2" Color="Color.Primary">
                            @if (context.Element.IsIngredient())
                            {
                                @(context.Price is not null ? Math.Round(
                                    context.Element.IsDynamic ?
                                    (float)context.Price! * -context.Element.Quantity * GetModuleAndLavishReducePercent() :
                                    (float)context.Price! * -context.Element.Quantity
                                , 2 ) + " $" : "")
                            }
                            else
                            {
                                @(context.Price is not null ? Math.Round((float)context.Price! * context.Element.Quantity, 2) + " $" : "")
                            }
                        </MudText>
                    </MudTd>
                </RowTemplate>
            </MudTable>

            @if (ShouldDisplayShare())
            {
                var list = GetProductsWithoutReintegratedElements();

                <MudStack>
                    <MudText Class="mt-2" Typo="Typo.body2">Price Sharing between outputs:</MudText>
                    <MudChart ChartType="ChartType.Donut"
                              LegendPosition="Position.Right"
                              Width="150px"
                              Height="150px"
                              InputData="@(list.Select(ue => (double)ue.Share).ToArray())"
                              InputLabels="@(list.Select(ue => ContextService.GetTranslation(ue.Element.ItemOrTag) + " (" + Math.Round(ue.Share * 100) + "%)").ToArray())"/>
                    <MudStack>
                        @for (var i = 0; i < list.Count; i++)
                        {
                            var product = list[i];
                            int index = i;

                            <MudStack Row>
                                <MudText Style="min-width: 100px">
                                    @(ContextService.GetTranslation(product.Element.ItemOrTag)):
                                </MudText>
                                <MudSlider T="float"
                                           Style="max-width: 350px"
                                           Color="@_sliderColors[index % 3]"
                                           Immediate="false"
                                           Value="product.Share"
                                           ValueChanged="@(v => ChangeShare(product, v))"
                                           Max="1"
                                           Min="0"
                                           Disabled="_lockedSliders.Contains(product)"
                                           Step="0.01f"/>
                                <MudIconButton
                                    Size="Size.Small"
                                    OnClick="@(() => ChangeLockSliders(product))"
                                    Icon="@(_lockedSliders.Contains(product) ? Icons.Material.Filled.Lock : Icons.Material.Outlined.Lock)"/>
                            </MudStack>
                        }
                    </MudStack>
                    <MudStack Row>
                        <MudButton OnClick="FirstOnly">Only First Product</MudButton>
                        <MudButton OnClick="Equality">Fair Distribution</MudButton>
                        @if (list.Any(e => (int)e.Element.Quantity != (int)list.Max(i => i.Element.Quantity)))
                        {
                            <MudButton OnClick="Equilibrate">Distribute by Quantity</MudButton>
                        }
                    </MudStack>
                </MudStack>
            }
        </MudStack>
    </DialogContent>
</MudDialog>


@code {
    [CascadingParameter] MudDialogInstance MudDialog { get; set; } = default!;

    [Parameter]
    public Recipe Recipe { get; set; }

    private readonly Color[] _sliderColors = [Color.Primary, Color.Tertiary, Color.Warning];
    private readonly List<UserElement> _lockedSliders = [];

    private void Ok()
    {
        MudDialog.Cancel();
    }

    private readonly TableGroupDefinition<UserElement> _userElementsDefinition = new()
    {
        Indentation = false,
        Expandable = false,
        IsInitiallyExpanded = true,
        Selector = (e) => e.Element.IsProduct() ? "Products" : "Ingredients"
    };

    private bool ShouldDisplayShare()
    {
        return Recipe.Elements.Count(e => e.IsProduct() && !UserServerDataService.UserElements.First(ue => ue.Element == e).IsReintegrated) > 1;
    }

    private async Task ChangeReintegrate(UserElement userElement, bool value)
    {
        userElement.IsReintegrated = value;
        await FirstOnly();
        await PriceCalculatorService.Calculate();
        StateHasChanged();
    }

    private void ChangeLockSliders(UserElement userElement)
    {
        if (_lockedSliders.Contains(userElement))
        {
            _lockedSliders.Remove(userElement);
        }
        else
        {
            _lockedSliders.Add(userElement);
        }
    }

    private float ElementSum(List<UserElement> userElements, bool? withReduction = true)
    {
        var ingredientCostSum = userElements.Sum(ue => ue.Price * ue.Element.Quantity * ((ue.Element.IsDynamic & (bool)withReduction!) ? GetModuleAndLavishReducePercent() : 1));
        return ingredientCostSum ?? 0f;
    }

    private List<UserElement> GetReintegratedElements()
    {
        return GetUserElements().Where(e => e.Element.IsProduct() && e.IsReintegrated).ToList();
    }

    private List<UserElement> GetProductsWithoutReintegratedElements()
    {
        return GetUserElements().Where(e => e.Element.IsProduct() && !e.IsReintegrated).ToList();
    }

    private float GetLaborPrice()
    {
        return Recipe.Labor
            * UserServerDataService.UserSetting!.CalorieCost / 1000
            * GetLaborReducePercent();
    }

    private float GetLaborReducePercent()
    {
        return (Recipe.Skill?.LaborReducePercent[UserServerDataService.UserSkills.First(us => us.Skill == Recipe.Skill).Level] ?? 1);
    }

    private float GetModuleAndLavishReducePercent()
    {
        var pluginModulePercent = UserServerDataService.UserCraftingTables.First(uct => uct.CraftingTable == Recipe.CraftingTable).PluginModule?.Percent ?? 1;
        var userRecipe = UserServerDataService.UserRecipes.First(ur => ur.Recipe == Recipe);
        var userSkill = UserServerDataService.UserSkills.First(us => us.Skill == Recipe.Skill);
        var lavishTalentValue = userRecipe.Recipe.Skill?.LavishTalentValue ?? 1f;
        return userSkill.HasLavishTalent ? pluginModulePercent * lavishTalentValue : pluginModulePercent;
    }

    private float GetCraftMinutePrice()
    {
        return Recipe.CraftMinutes
            * UserServerDataService.UserCraftingTables.First(u => u.CraftingTable == Recipe.CraftingTable).CraftMinuteFee;
    }

    public string GetFormatedCraftTime(float craftMinutes)
    {
        int totalSeconds = (int)(craftMinutes * 60);
        int minutes = totalSeconds / 60;
        int seconds = totalSeconds % 60;
        return $"{minutes} min {seconds} s";
    }

    private List<UserElement> GetUserElements()
    {
        return Recipe.Elements.OrderBy(e => e.IsProduct()).ThenBy(e => e.Index).Select(e => UserServerDataService.UserElements.First(ue => ue.Element == e))
            .ToList();
    }

    private async Task ChangeShare(UserElement userElement, float value)
    {
        var others = GetProductsWithoutReintegratedElements().Where(ue => ue != userElement).ToList();
        var lockedOthers = others.Where(ue => _lockedSliders.Contains(ue)).ToList();
        var unlockedOthers = others.Where(ue => !_lockedSliders.Contains(ue)).ToList();

        if (unlockedOthers.Count == 0)
        {
            return;
        }

        var result = (1 - lockedOthers.Sum(l => l.Share) - value) / unlockedOthers.Count;

        if (result < 0)
        {
            return;
        }

        userElement.Share = value;

        foreach (var other in unlockedOthers)
        {
            other.Share = (1 - lockedOthers.Sum(l => l.Share) - userElement.Share) / unlockedOthers.Count;
        }

        await PriceCalculatorService.Calculate();
        StateHasChanged();
    }

    private async Task Equality()
    {
        var products = Recipe.Elements.Where(e => e.IsProduct()).ToList();

        foreach (var product in products)
        {
            var associatedUserElement = UserServerDataService.UserElements.First(ue => ue.Element == product);

            associatedUserElement.Share = 1f / products.Count;
        }

        await PriceCalculatorService.Calculate();
        StateHasChanged();
    }

    private async Task Equilibrate()
    {
        var products = Recipe.Elements.Where(e => e.IsProduct()).ToList();
        var totalQuantity = products.Sum(p => p.Quantity);

        foreach (var product in products)
        {
            var associatedUserElement = UserServerDataService.UserElements.First(ue => ue.Element == product);

            associatedUserElement.Share = product.Quantity / totalQuantity;
        }

        await PriceCalculatorService.Calculate();
        StateHasChanged();
    }

    private async Task FirstOnly()
    {
        var products = Recipe.Elements.Where(e => e.IsProduct()).ToList();

        foreach (var product in products)
        {
            var associatedUserElement = UserServerDataService.UserElements.First(ue => ue.Element == product);

            associatedUserElement.Share = product.Index == 0 ? 1f : 0f;
        }

        await PriceCalculatorService.Calculate();
        StateHasChanged();
    }
}
